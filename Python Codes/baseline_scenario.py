# -*- coding: utf-8 -*-
"""Baseline Scenario.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UQMtl7ok8JJJs8RZjjAxZP5Sg82I4BDb

Baseline Scenario using SimPy
"""

import simpy
import random
import matplotlib.pyplot as plt

# Parameters for the simulation
total_steps = 100  # Total simulation steps (e.g., days)
initial_co2_emissions = 1000  # Initial CO2 emissions (tons)
initial_resource_usage = 100  # Initial resource usage (units per day)
response_time = 5  # Average response time (in days)

# Variables to store simulation results
co2_emissions = []
resource_usage = []
response_times = []

def city_environment(env):
    """Simulates the city environment under baseline conditions."""
    global initial_co2_emissions, initial_resource_usage, response_time

    while True:
        # CO2 emissions increase by a random factor (e.g., due to inefficiencies)
        emission_change = random.uniform(-5, 10)
        initial_co2_emissions += emission_change
        co2_emissions.append(initial_co2_emissions)

        # Resource usage fluctuates due to demand
        resource_change = random.uniform(-2, 5)
        initial_resource_usage += resource_change
        resource_usage.append(initial_resource_usage)

        # Response time fluctuates
        time_change = random.uniform(-1, 1)
        current_response_time = max(response_time + time_change, 0)
        response_times.append(current_response_time)

        yield env.timeout(1)  # Simulate one timestep

# Set up the SimPy environment
env = simpy.Environment()
env.process(city_environment(env))
env.run(until=total_steps)

# Visualization of results
plt.figure(figsize=(10, 6))

# Plot CO2 emissions
plt.subplot(3, 1, 1)
plt.plot(co2_emissions, label='CO2 Emissions (tons)', color='red')
plt.title('Baseline Scenario Simulation')
plt.ylabel('CO2 Emissions')
plt.legend()

# Plot Resource Usage
plt.subplot(3, 1, 2)
plt.plot(resource_usage, label='Resource Usage (units)', color='blue')
plt.ylabel('Resource Usage')
plt.legend()

# Plot Response Times
plt.subplot(3, 1, 3)
plt.plot(response_times, label='Response Time (days)', color='green')
plt.xlabel('Time (days)')
plt.ylabel('Response Time')
plt.legend()

plt.tight_layout()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Define simulation parameters
num_simulations = 1000  # Number of Monte Carlo simulations
num_years = 10  # Simulation time horizon in years

# Baseline metrics for the selected city
baseline_metrics = {
    'carbon_emissions': 50000,  # in tons/year
    'energy_consumption': 100000,  # in MWh/year
    'resilience_index': 0.5,  # scale from 0 to 1
    'cost': 2000000,  # in USD/year
    'equity_score': 0.6  # scale from 0 to 1
}

# Monte Carlo simulation function for baseline scenario
def run_baseline_simulation(baseline_metrics, num_simulations, num_years):
    results = []
    for _ in range(num_simulations):
        metrics = baseline_metrics.copy()
        for year in range(num_years):
            metrics['carbon_emissions'] *= np.random.uniform(0.95, 1.05)  # Random annual variation
            metrics['energy_consumption'] *= np.random.uniform(0.95, 1.05)
            metrics['resilience_index'] += np.random.uniform(-0.01, 0.01)  # Small random fluctuation
            metrics['cost'] *= np.random.uniform(0.95, 1.05)
            metrics['equity_score'] += np.random.uniform(-0.01, 0.01)
        results.append(metrics)
    return pd.DataFrame(results)

# Run baseline simulation
baseline_results = run_baseline_simulation(baseline_metrics, num_simulations, num_years)

# Reliability Test: Consistency of baseline simulation across multiple runs
reliability_test = []
for _ in range(5):  # Run 5 independent tests
    test_results = run_baseline_simulation(baseline_metrics, num_simulations, num_years)
    reliability_test.append(test_results['carbon_emissions'].mean())

# Validity Test: Compare baseline simulation results with theoretical expectations
validity_results = baseline_results.mean().to_dict()

# Sensitivity Analysis: Impact of varying annual variation range on carbon emissions
sensitivity_results = []
variation_ranges = np.linspace(0.01, 0.1, 10)  # Test different variation ranges
for variation in variation_ranges:
    adjusted_baseline_metrics = baseline_metrics.copy()
    temp_results = []
    for _ in range(num_simulations):
        metrics = adjusted_baseline_metrics.copy()
        for year in range(num_years):
            metrics['carbon_emissions'] *= np.random.uniform(1 - variation, 1 + variation)
        temp_results.append(metrics['carbon_emissions'])
    sensitivity_results.append(np.mean(temp_results))

# Plot Sensitivity Analysis
plt.figure(figsize=(10, 6))
plt.plot(variation_ranges, sensitivity_results, marker='o', label='Carbon Emissions')
plt.title('Sensitivity Analysis of Annual Variation Range on Carbon Emissions')
plt.xlabel('Annual Variation Range')
plt.ylabel('Mean Carbon Emissions (tons/year)')
plt.legend()
plt.grid()
plt.show()

# Summarize Results
print("Baseline Simulation Results:")
print(baseline_results.describe())

# Reliability Test Results
print("\nReliability Test Results:")
print(reliability_test)

# Validity Test Results
print("\nValidity Test Results:")
print(validity_results)

# Python script to perform simulation with reliability, validity, and sensitivity tests

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Define the variables and their properties for the simulation
variables = {
    "Variable Name": [
        "Community Engagement",
        "Public Awareness",
        "Data Quality and Accessibility",
        "Digital Divide",
        "Resource Allocation Efficiency",
        "Cost of Governance",
        "Carbon Footprint",
        "Biodiversity and Green Spaces",
        "Disaster Response Capacity",
        "Infrastructure Vulnerability"
    ],
    "Description": [
        "Level of citizen participation in urban planning and disaster management.",
        "Awareness of climate change and resource conservation practices.",
        "Current state of data collection systems, including gaps in real-time data availability.",
        "Access to digital tools and connectivity within the population.",
        "Efficiency in allocating resources like energy, water, and waste management.",
        "Operational costs of current urban management practices.",
        "Baseline greenhouse gas emissions from transport, energy, and waste sectors.",
        "Availability and health of green infrastructure and biodiversity.",
        "Current disaster response times and resource readiness.",
        "Condition and adaptability of critical infrastructure."
    ],
    "Measurement Unit": [
        "% of population engaged",
        "% of population aware",
        "Data quality score (0-10)",
        "% of population with digital access",
        "% efficiency in resource use",
        "$ per capita",
        "Metric tons of CO2",
        "% of green cover",
        "Response time in hours",
        "Vulnerability index (0-10)"
    ],
    "Baseline Value": [
        10, 20, 5, 30, 50, 500, 200, 15, 48, 7
    ],
    "Target Value": [
        70, 80, 8, 90, 90, 300, 100, 25, 12, 3
    ]
}

# Create a DataFrame to store the variables
baseline_variables = pd.DataFrame(variables)

# Simulation settings
time_steps = 10  # Number of time steps for the simulation
repetitions = 5  # Number of repetitions for reliability testing

# Initialize simulation results
simulation_results = []

for run in range(repetitions):  # For reliability testing
    run_data = {"Time Step": list(range(1, time_steps + 1))}
    for index, row in baseline_variables.iterrows():
        baseline = row["Baseline Value"]
        target = row["Target Value"]
        noise = np.random.normal(0, 1, time_steps)  # Adding slight randomness for sensitivity
        simulated_values = np.linspace(baseline, target, time_steps) + noise
        run_data[row["Variable Name"]] = simulated_values
    simulation_results.append(pd.DataFrame(run_data))

# Combine all runs into one DataFrame for analysis
all_runs = pd.concat(simulation_results, keys=range(repetitions), names=["Run", "Index"])

# Perform Sensitivity Analysis
sensitivity_results = all_runs.groupby("Time Step").agg(["mean", "std"])
sensitivity_results.columns = ["_".join(col) for col in sensitivity_results.columns]

# Validity Testing (compare to an ideal/reference dataset)
reference_values = baseline_variables.set_index("Variable Name")["Target Value"].to_dict()
validity_results = {}
for variable in baseline_variables["Variable Name"]:
    final_values = all_runs.loc[(slice(None), time_steps - 1), variable]
    validity_results[variable] = {
        "Mean Simulated": final_values.mean(),
        "Reference": reference_values[variable],
        "Error (%)": abs((final_values.mean() - reference_values[variable]) / reference_values[variable]) * 100
    }
validity_results_df = pd.DataFrame(validity_results).T

# Plot sensitivity results
plt.figure(figsize=(12, 8))
for variable in baseline_variables["Variable Name"]:
    plt.errorbar(
        sensitivity_results.index,
        sensitivity_results[f"{variable}_mean"],
        yerr=sensitivity_results[f"{variable}_std"],
        label=variable
    )

plt.title("Sensitivity Analysis Results")
plt.xlabel("Time Step")
plt.ylabel("Value (with Error Bars)")
plt.legend(loc="upper left")
plt.grid(True)
plt.show()

# Save all results
all_runs.reset_index().to_csv("simulation_with_reliability.csv", index=False)
sensitivity_results.to_csv("sensitivity_analysis_results.csv")
validity_results_df.to_csv("validity_test_results.csv")

print("Simulation completed with reliability, validity, and sensitivity tests.")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Define simulation parameters
num_simulations = 1000  # Number of Monte Carlo simulations
num_years = 10  # Simulation time horizon in years

# Define baseline metrics for the case study
baseline_metrics = {
    'carbon_emissions': 50000,  # in tons/year
    'energy_consumption': 100000,  # in MWh/year
    'resilience_index': 0.5,  # scale from 0 to 1
    'cost': 2000000,  # in USD/year
    'equity_score': 0.6  # scale from 0 to 1
}

# Define scenario adjustment factors
scenarios = {
    'resource_constrained': {
        'emission_reduction': 0.1,  # 10% reduction
        'energy_savings': 0.15,  # 15% savings
        'resilience_increase': 0.05,  # 5% increase
        'cost_increase': 0.05,  # 5% increase
        'equity_boost': 0.02  # 2% increase
    },
    'high_resource': {
        'emission_reduction': 0.3,  # 30% reduction
        'energy_savings': 0.4,  # 40% savings
        'resilience_increase': 0.2,  # 20% increase
        'cost_increase': 0.3,  # 30% increase
        'equity_boost': 0.1  # 10% increase
    },
    'policy_driven': {
        'emission_reduction': 0.2,
        'energy_savings': 0.25,
        'resilience_increase': 0.1,
        'cost_increase': 0.1,
        'equity_boost': 0.05
    },
    'emergency_response': {
        'emission_reduction': 0.15,
        'energy_savings': 0.2,
        'resilience_increase': 0.25,
        'cost_increase': 0.2,
        'equity_boost': 0.08
    }
}

# Monte Carlo simulation function
def run_simulation(scenario, baseline_metrics, num_simulations, num_years):
    results = []
    for _ in range(num_simulations):
        metrics = baseline_metrics.copy()
        for year in range(num_years):
            metrics['carbon_emissions'] *= (1 - scenario['emission_reduction']) * np.random.uniform(0.9, 1.1)
            metrics['energy_consumption'] *= (1 - scenario['energy_savings']) * np.random.uniform(0.9, 1.1)
            metrics['resilience_index'] += scenario['resilience_increase'] * np.random.uniform(0.9, 1.1)
            metrics['cost'] *= (1 + scenario['cost_increase']) * np.random.uniform(0.9, 1.1)
            metrics['equity_score'] += scenario['equity_boost'] * np.random.uniform(0.9, 1.1)
        results.append(metrics)
    return pd.DataFrame(results)

# Run simulations for all scenarios
simulation_results = {}
for scenario_name, adjustments in scenarios.items():
    simulation_results[scenario_name] = run_simulation(adjustments, baseline_metrics, num_simulations, num_years)

# Reliability Test: Consistency of results across multiple runs
reliability_test = []
for _ in range(5):  # Run 5 independent tests
    test_results = run_simulation(scenarios['resource_constrained'], baseline_metrics, num_simulations, num_years)
    reliability_test.append(test_results['carbon_emissions'].mean())

# Validity Test: Compare simulation results with expected theoretical outcomes
validity_results = {}
for scenario_name, results in simulation_results.items():
    validity_results[scenario_name] = results.mean().to_dict()

# Sensitivity Analysis: Impact of varying a key parameter (e.g., emission reduction)
sensitivity_results = []
emission_reductions = np.linspace(0.05, 0.4, 10)  # Test different emission reduction rates
for reduction in emission_reductions:
    adjusted_scenario = scenarios['resource_constrained'].copy()
    adjusted_scenario['emission_reduction'] = reduction
    sensitivity_result = run_simulation(adjusted_scenario, baseline_metrics, num_simulations, num_years)
    sensitivity_results.append(sensitivity_result['carbon_emissions'].mean())

# Plot Sensitivity Analysis
plt.figure(figsize=(10, 6))
plt.plot(emission_reductions, sensitivity_results, marker='o', label='Carbon Emissions')
plt.title('Sensitivity Analysis of Emission Reduction Rates')
plt.xlabel('Emission Reduction Rate')
plt.ylabel('Mean Carbon Emissions (tons/year)')
plt.legend()
plt.grid()
plt.show()

# Summarize Results
for scenario_name, results in simulation_results.items():
    print(f"\nScenario: {scenario_name}")
    print(results.describe())

# Reliability Test Results
print("\nReliability Test Results:")
print(reliability_test)

# Validity Test Results
print("\nValidity Test Results:")
for scenario, metrics in validity_results.items():
    print(f"{scenario}: {metrics}")

"""3RD Stress Scenario"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Define simulation parameters
num_simulations = 1000  # Number of Monte Carlo simulations
num_years = 10  # Simulation time horizon in years

# Baseline metrics for the selected city
baseline_metrics = {
    'carbon_emissions': 50000,  # in tons/year
    'energy_consumption': 100000,  # in MWh/year
    'resilience_index': 0.5,  # scale from 0 to 1
    'cost': 2000000,  # in USD/year
    'equity_score': 0.6  # scale from 0 to 1
}

# Define extreme event adjustments
stress_scenarios = {
    'flood': {
        'carbon_emissions_increase': 0.15,  # 15% increase
        'energy_consumption_increase': 0.2,  # 20% increase
        'resilience_drop': -0.2,  # 20% drop
        'cost_increase': 0.3,  # 30% increase
        'equity_drop': -0.1  # 10% drop
    },
    'drought': {
        'carbon_emissions_increase': 0.1,
        'energy_consumption_increase': 0.25,
        'resilience_drop': -0.15,
        'cost_increase': 0.25,
        'equity_drop': -0.08
    },
    'economic_constraints': {
        'carbon_emissions_increase': 0.05,
        'energy_consumption_increase': 0.1,
        'resilience_drop': -0.1,
        'cost_increase': 0.4,
        'equity_drop': -0.15
    }
}

# Monte Carlo simulation function for stress scenarios
def run_stress_simulation(stress_scenario, baseline_metrics, num_simulations, num_years):
    results = []
    for _ in range(num_simulations):
        metrics = baseline_metrics.copy()
        for year in range(num_years):
            metrics['carbon_emissions'] *= (1 + stress_scenario['carbon_emissions_increase']) * np.random.uniform(0.95, 1.05)
            metrics['energy_consumption'] *= (1 + stress_scenario['energy_consumption_increase']) * np.random.uniform(0.95, 1.05)
            metrics['resilience_index'] += stress_scenario['resilience_drop'] * np.random.uniform(0.95, 1.05)
            metrics['cost'] *= (1 + stress_scenario['cost_increase']) * np.random.uniform(0.95, 1.05)
            metrics['equity_score'] += stress_scenario['equity_drop'] * np.random.uniform(0.95, 1.05)
        results.append(metrics)
    return pd.DataFrame(results)

# Run simulations for all stress scenarios
stress_results = {}
for scenario_name, adjustments in stress_scenarios.items():
    stress_results[scenario_name] = run_stress_simulation(adjustments, baseline_metrics, num_simulations, num_years)

# Reliability Test: Consistency of stress scenario simulations across multiple runs
reliability_test = {}
for scenario_name, adjustments in stress_scenarios.items():
    test_results = []
    for _ in range(5):  # Run 5 independent tests
        scenario_results = run_stress_simulation(adjustments, baseline_metrics, num_simulations, num_years)
        test_results.append(scenario_results['carbon_emissions'].mean())
    reliability_test[scenario_name] = test_results

# Validity Test: Compare stress scenario simulation results with theoretical expectations
validity_results = {}
for scenario_name, results in stress_results.items():
    validity_results[scenario_name] = results.mean().to_dict()

# Sensitivity Analysis: Impact of varying cost increase rates on total cost
sensitivity_results = {}
for scenario_name, adjustments in stress_scenarios.items():
    cost_increases = np.linspace(0.1, 0.5, 10)  # Test different cost increase rates
    temp_results = []
    for increase in cost_increases:
        adjusted_scenario = adjustments.copy()
        adjusted_scenario['cost_increase'] = increase
        scenario_results = run_stress_simulation(adjusted_scenario, baseline_metrics, num_simulations, num_years)
        temp_results.append(scenario_results['cost'].mean())
    sensitivity_results[scenario_name] = temp_results

# Plot Sensitivity Analysis
plt.figure(figsize=(12, 8))
for scenario_name, results in sensitivity_results.items():
    plt.plot(np.linspace(0.1, 0.5, 10), results, marker='o', label=f'{scenario_name.capitalize()} Cost Impact')
plt.title('Sensitivity Analysis of Cost Increase Rates in Stress Scenarios')
plt.xlabel('Cost Increase Rate')
plt.ylabel('Mean Total Cost (USD/year)')
plt.legend()
plt.grid()
plt.show()

# Summarize Results
for scenario_name, results in stress_results.items():
    print(f"\nStress Scenario: {scenario_name.capitalize()}")
    print(results.describe())

# Reliability Test Results
print("\nReliability Test Results:")
for scenario_name, test_results in reliability_test.items():
    print(f"{scenario_name.capitalize()}: {test_results}")

# Validity Test Results
print("\nValidity Test Results:")
for scenario, metrics in validity_results.items():
    print(f"{scenario.capitalize()}: {metrics}")