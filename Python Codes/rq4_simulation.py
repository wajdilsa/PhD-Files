# -*- coding: utf-8 -*-
"""RQ4 Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YZ-hdU4uVckmNL5--g1kkQGWJ6fDIO25
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(style="whitegrid")
sns.set_palette(sns.color_palette("husl", 9))

###############################################################################
# SCENARIO DEFINITION
###############################################################################

def get_scenario_parameters(scenario="baseline"):
    """
    Returns scenario-specific parameters for simulating the AI framework’s
    performance in a selected low-income city context. Includes:
    - City-Specific Data (population, infrastructure, resource availability)
    - AI Framework Parameters (energy optimization, traffic mgmt)
    - Governance and Community Factors (policy intervention, engagement)
    - Performance Constraints (data availability, financial resources)
    """

    if scenario == "baseline":
        # 1) Baseline Scenario
        #    Reflects the city’s current state without major AI interventions,
        #    providing a benchmark for measuring the framework’s impact.
        params = {
            # City-Specific Data
            "population_size": (100000, 150000),    # e.g., range for population
            "population_density": (2000, 3000),     # people per km^2
            "infrastructure_quality": (0.3, 0.5),    # 0=poor, 1=excellent
            "resource_availability": (0.4, 0.6),     # fraction of city resource needs met

            # Urban Challenges
            "traffic_congestion": (0.5, 0.8),        # fraction of roads congested
            "energy_consumption": (1000, 2000),      # daily energy usage (units are placeholders)
            "waste_efficiency": (0.3, 0.5),          # 0=inefficient, 1=perfect
            "climate_risk": (0.2, 0.4),             # probability or severity metric

            # AI Framework Parameters
            "ai_energy_opt_factor": (0.0, 0.0),      # In baseline, no AI optimization
            "ai_traffic_mgmt_factor": (0.0, 0.0),
            "ai_waste_mgmt_factor": (0.0, 0.0),

            # Governance
            "policy_intervention_rate": (0.1, 0.2),
            "budget_allocation": (50, 100),          # e.g., in $k
            "gov_quality_index": (0.3, 0.5),

            # Community Factors
            "public_participation": (0.2, 0.4),
            "feedback_loops": (0.1, 0.2),
            "inequality_index": (0.3, 0.5),

            # Performance Constraints
            "data_availability": (0.3, 0.5),         # fraction of needed data available
            "sensor_coverage": (0.2, 0.4),
            "network_bandwidth": (5, 10),            # MB/s
            "financial_resources": (100, 300)        # e.g., in $k
        }
        return params

    elif scenario == "optimized_resource":
        # 2) Optimized Resource Scenario
        #    Test the framework with AI-driven energy, transportation, and waste management solutions.
        params = {
            "population_size": (120000, 180000),
            "population_density": (2500, 3500),
            "infrastructure_quality": (0.4, 0.6),
            "resource_availability": (0.5, 0.7),

            "traffic_congestion": (0.4, 0.7),
            "energy_consumption": (1200, 2200),
            "waste_efficiency": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_opt_factor": (0.02, 0.05),
            "ai_traffic_mgmt_factor": (0.02, 0.05),
            "ai_waste_mgmt_factor": (0.01, 0.04),

            "policy_intervention_rate": (0.2, 0.4),
            "budget_allocation": (100, 300),
            "gov_quality_index": (0.4, 0.6),

            "public_participation": (0.2, 0.4),
            "feedback_loops": (0.2, 0.4),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.4, 0.7),
            "sensor_coverage": (0.4, 0.6),
            "network_bandwidth": (10, 20),
            "financial_resources": (200, 500)
        }
        return params

    elif scenario == "stress_test":
        # 3) Stress-Test Scenario
        #    Introduce extreme events (floods, grid failures) to check
        #    the framework’s robustness and adaptability.
        params = {
            "population_size": (100000, 150000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.3, 0.6),
            "resource_availability": (0.3, 0.5),

            "traffic_congestion": (0.5, 0.9),
            "energy_consumption": (1000, 2500),
            "waste_efficiency": (0.3, 0.6),
            # climate risk is higher
            "climate_risk": (0.4, 0.7),

            "ai_energy_opt_factor": (0.01, 0.03),
            "ai_traffic_mgmt_factor": (0.01, 0.03),
            "ai_waste_mgmt_factor": (0.01, 0.03),

            "policy_intervention_rate": (0.1, 0.3),
            "budget_allocation": (100, 200),
            "gov_quality_index": (0.3, 0.5),

            "public_participation": (0.1, 0.3),
            "feedback_loops": (0.1, 0.3),
            "inequality_index": (0.4, 0.6),

            "data_availability": (0.2, 0.4),
            "sensor_coverage": (0.2, 0.4),
            "network_bandwidth": (3, 8),
            "financial_resources": (100, 300)
        }
        return params

    elif scenario == "community_engagement":
        # 4) Community Engagement Scenario
        #    Enhanced public participation and feedback loops.
        params = {
            "population_size": (100000, 150000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.4, 0.6),
            "resource_availability": (0.4, 0.6),

            "traffic_congestion": (0.4, 0.7),
            "energy_consumption": (1000, 2000),
            "waste_efficiency": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_opt_factor": (0.01, 0.04),
            "ai_traffic_mgmt_factor": (0.01, 0.04),
            "ai_waste_mgmt_factor": (0.01, 0.03),

            "policy_intervention_rate": (0.2, 0.4),
            "budget_allocation": (100, 300),
            "gov_quality_index": (0.4, 0.7),

            # Higher public participation & feedback
            "public_participation": (0.4, 0.7),
            "feedback_loops": (0.4, 0.7),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.3, 0.5),
            "sensor_coverage": (0.3, 0.5),
            "network_bandwidth": (5, 10),
            "financial_resources": (100, 300)
        }
        return params

    elif scenario == "governance_reform":
        # 5) Governance Reform Scenario
        #    Improved governance inputs (budget, policy, responsiveness).
        params = {
            "population_size": (100000, 160000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.4, 0.7),
            "resource_availability": (0.4, 0.7),

            "traffic_congestion": (0.4, 0.7),
            "energy_consumption": (1000, 2000),
            "waste_efficiency": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_opt_factor": (0.01, 0.03),
            "ai_traffic_mgmt_factor": (0.01, 0.04),
            "ai_waste_mgmt_factor": (0.01, 0.03),

            # Enhanced governance
            "policy_intervention_rate": (0.4, 0.7),
            "budget_allocation": (300, 600),
            "gov_quality_index": (0.5, 0.8),

            "public_participation": (0.2, 0.4),
            "feedback_loops": (0.2, 0.4),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.4, 0.6),
            "sensor_coverage": (0.4, 0.7),
            "network_bandwidth": (10, 20),
            "financial_resources": (300, 800)
        }
        return params

    else:
        raise ValueError(f"Unknown scenario: {scenario}")

def sample_param(range_tuple):
    """Utility to sample from a uniform distribution given a (min, max) tuple."""
    return np.random.uniform(*range_tuple)

###############################################################################
# 2. SIMULATION LOGIC
###############################################################################

def run_simulation(time_steps=12, param_dict=None):
    """
    Simulates how an AI framework performs in a selected low-income city context.
    Time series metrics include:
      - CO2 emission reductions, commute times, waste mgmt efficiency
      - Adaptability (constraints, coverage, etc.)
      - Governance impact (policy response, governance score)
      - Sustainability (air quality, energy consumption)
      - Economic & Community well-being (cost savings, satisfaction)
    """

    if param_dict is None:
        raise ValueError("No parameter dictionary provided for the simulation.")

    # Extract scenario-specific parameters
    # City-Specific Data
    population_size     = sample_param(param_dict["population_size"])
    pop_density         = sample_param(param_dict["population_density"])
    infra_quality       = sample_param(param_dict["infrastructure_quality"])
    resource_avail      = sample_param(param_dict["resource_availability"])

    # Urban Challenges
    traffic_congestion  = sample_param(param_dict["traffic_congestion"])
    energy_usage        = sample_param(param_dict["energy_consumption"])
    waste_efficiency    = sample_param(param_dict["waste_efficiency"])
    climate_risk        = sample_param(param_dict["climate_risk"])

    # AI Framework Params
    ai_energy_factor    = sample_param(param_dict["ai_energy_opt_factor"])
    ai_traffic_factor   = sample_param(param_dict["ai_traffic_mgmt_factor"])
    ai_waste_factor     = sample_param(param_dict["ai_waste_mgmt_factor"])

    # Governance
    policy_rate         = sample_param(param_dict["policy_intervention_rate"])
    budget_alloc        = sample_param(param_dict["budget_allocation"])
    gov_quality         = sample_param(param_dict["gov_quality_index"])

    # Community
    participation       = sample_param(param_dict["public_participation"])
    feedback            = sample_param(param_dict["feedback_loops"])
    inequality_index    = sample_param(param_dict["inequality_index"])

    # Performance Constraints
    data_avail          = sample_param(param_dict["data_availability"])
    sensor_coverage     = sample_param(param_dict["sensor_coverage"])
    bandwidth           = sample_param(param_dict["network_bandwidth"])
    finances            = sample_param(param_dict["financial_resources"])

    # Initialize states
    co2_reduction_ts          = []
    commute_time_ts           = []
    waste_mgmt_ts            = []
    adaptability_ts           = []
    gov_impact_ts             = []
    sustainability_ts         = []
    econ_impact_ts            = []
    community_wellbeing_ts    = []

    # Some simplified dynamic states
    current_co2_reduction   = 0.0     # fraction of baseline CO2 reduced
    current_commute_time    = 30.0    # example baseline: 30 minutes
    current_waste_effic     = waste_efficiency
    current_adaptability    = 0.2     # how well AI adapts to constraints
    current_gov_impact      = gov_quality
    current_sustainability  = 0.3     # environment-sustainability index
    current_econ_impact     = 0.0     # cost savings or productivity gains
    current_community_score = 0.4     # e.g., satisfaction or engagement index

    for t in range(time_steps):
        # 1) AI improvements in energy, traffic, waste
        #    Factor in data availability & sensor coverage
        energy_opt_gain  = ai_energy_factor   * data_avail * sensor_coverage
        traffic_opt_gain = ai_traffic_factor  * data_avail * sensor_coverage
        waste_opt_gain   = ai_waste_factor    * data_avail * sensor_coverage

        # 2) CO2 Reduction
        #    If AI is strong & resource is adequate, we reduce CO2
        #    Also check finances or climate_risk (which might degrade progress)
        finance_limit = max(1.0, (1.0 - finances * 0.001))
        climate_loss  = climate_risk * 0.02
        current_co2_reduction += (energy_opt_gain * 0.02) - climate_loss - finance_limit*0.0001
        current_co2_reduction = max(0, min(1.0, current_co2_reduction))

        co2_reduction_ts.append(current_co2_reduction)

        # 3) Commute Times
        #    Reduced by traffic_opt_gain but worsened by population growth & infra_quality
        infra_bonus  = infra_quality * 0.01
        pop_density_penalty = pop_density * 0.0001
        current_commute_time -= (traffic_opt_gain * 0.5) + (infra_bonus*2)
        current_commute_time += pop_density_penalty
        current_commute_time = max(5.0, current_commute_time)  # clamp minimal commute

        commute_time_ts.append(current_commute_time)

        # 4) Waste Management Efficiency
        #    Gains from AI, offset by climate risk or inequality
        current_waste_effic += (waste_opt_gain * 0.01) - (inequality_index * 0.001)
        current_waste_effic = max(0, min(1.0, current_waste_effic))
        waste_mgmt_ts.append(current_waste_effic)

        # 5) Adaptability
        #    Measures how many constraints the framework can handle
        #    If sensor coverage is low, or finances are limited, adaptability is reduced
        #    But governance & community engagement might help
        constraint_factor = data_avail + sensor_coverage + (finances*0.001)
        gov_community_boost = policy_rate + participation + feedback
        current_adaptability += (constraint_factor * 0.001) + (gov_community_boost * 0.001)
        current_adaptability = max(0, min(1.0, current_adaptability))
        adaptability_ts.append(current_adaptability)

        # 6) Governance Impact
        #    Policy response time, governance score, etc.
        #    If AI is strong & feedback loops are high, we reduce policy lag
        gov_improve = (gov_quality * 0.01) + (feedback * 0.01)
        current_gov_impact += gov_improve - climate_risk*0.001
        current_gov_impact = max(0, min(1.0, current_gov_impact))
        gov_impact_ts.append(current_gov_impact)

        # 7) Sustainability
        #    Reflect improvements in air quality, reduced energy usage
        #    Also degrade if resource_avail is low or climate risk is high
        resource_gain = resource_avail * 0.01
        climate_penalty = climate_risk * 0.003
        current_sustainability += (energy_opt_gain + traffic_opt_gain)*0.01 + resource_gain - climate_penalty
        current_sustainability = max(0, min(1.0, current_sustainability))
        sustainability_ts.append(current_sustainability)

        # 8) Economic & Community Impact
        #    E.g., cost savings from AI optimizations or engagement improvements
        cost_savings = (energy_opt_gain + traffic_opt_gain + waste_opt_gain)*100
        community_boost = (participation + feedback)*0.5
        current_econ_impact += cost_savings*0.01
        current_community_score += community_boost*0.001
        current_community_score = max(0, min(1.0, current_community_score))

        econ_impact_ts.append(current_econ_impact)
        community_wellbeing_ts.append(current_community_score)

    return {
        "CO2_Reduction_TS": co2_reduction_ts,
        "Commute_Time_TS": commute_time_ts,
        "Waste_Mgmt_Efficiency_TS": waste_mgmt_ts,
        "Adaptability_TS": adaptability_ts,
        "Gov_Impact_TS": gov_impact_ts,
        "Sustainability_TS": sustainability_ts,
        "Econ_Impact_TS": econ_impact_ts,
        "Community_Wellbeing_TS": community_wellbeing_ts
    }

###############################################################################
# 3. MONTE CARLO SIMULATION
###############################################################################

def run_monte_carlo(n_runs=50, time_steps=12, scenario="baseline"):
    """
    Execute multiple simulations for a given scenario, storing the final step's
    outputs in a DataFrame for easy correlation or analysis.
    """
    scenario_ranges = get_scenario_parameters(scenario)
    final_results = {
        "CO2_Reduction": [],
        "Commute_Time": [],
        "Waste_Mgmt_Efficiency": [],
        "Adaptability": [],
        "Gov_Impact": [],
        "Sustainability": [],
        "Econ_Impact": [],
        "Community_Wellbeing": []
    }

    for _ in range(n_runs):
        param_dict = scenario_ranges  # All we need are the param distributions
        sim_data = run_simulation(time_steps=time_steps, param_dict=param_dict)

        # Store the final step of each time series
        final_results["CO2_Reduction"].append(sim_data["CO2_Reduction_TS"][-1])
        final_results["Commute_Time"].append(sim_data["Commute_Time_TS"][-1])
        final_results["Waste_Mgmt_Efficiency"].append(sim_data["Waste_Mgmt_Efficiency_TS"][-1])
        final_results["Adaptability"].append(sim_data["Adaptability_TS"][-1])
        final_results["Gov_Impact"].append(sim_data["Gov_Impact_TS"][-1])
        final_results["Sustainability"].append(sim_data["Sustainability_TS"][-1])
        final_results["Econ_Impact"].append(sim_data["Econ_Impact_TS"][-1])
        final_results["Community_Wellbeing"].append(sim_data["Community_Wellbeing_TS"][-1])

    df_final = pd.DataFrame(final_results)
    return df_final

###############################################################################
# 4. VISUALIZATION & STAKEHOLDER REPORT
###############################################################################

def visualize_time_series(sim_data, title="Simulation Time Series"):
    """
    Plot time series of key metrics from a single simulation run.
    """
    df = pd.DataFrame({
        "CO2_Reduction": sim_data["CO2_Reduction_TS"],
        "Commute_Time": sim_data["Commute_Time_TS"],
        "Waste_Mgmt_Efficiency": sim_data["Waste_Mgmt_Efficiency_TS"],
        "Adaptability": sim_data["Adaptability_TS"],
        "Gov_Impact": sim_data["Gov_Impact_TS"],
        "Sustainability": sim_data["Sustainability_TS"],
        "Econ_Impact": sim_data["Econ_Impact_TS"],
        "Community_Wellbeing": sim_data["Community_Wellbeing_TS"]
    })
    df.plot(subplots=True, figsize=(12,12), layout=(4,2), sharex=True)
    plt.suptitle(title)
    plt.tight_layout()
    plt.show()

def visualize_final_correlations(df_results, title="Final Step Correlation"):
    """
    Create a correlation heatmap of final outputs across multiple runs.
    """
    corr_matrix = df_results.corr()
    plt.figure(figsize=(8, 6))
    sns.heatmap(corr_matrix, annot=True, cmap="viridis", fmt=".2f")
    plt.title(title)
    plt.tight_layout()
    plt.show()

def stakeholder_report(df_results, scenario_name="Baseline"):
    """
    Print a structured summary of final results for stakeholder consumption.
    """
    print(f"\n===== {scenario_name.upper()} SCENARIO - STAKEHOLDER REPORT =====")
    summary_stats = df_results.describe(percentiles=[0.1, 0.5, 0.9])
    print(summary_stats)

    avg_co2    = df_results["CO2_Reduction"].mean()
    avg_adapt  = df_results["Adaptability"].mean()
    avg_sustain= df_results["Sustainability"].mean()
    avg_comm   = df_results["Community_Wellbeing"].mean()

    print("\nKey Highlights:")
    print(f" - Average CO2 Reduction: {avg_co2:.2f} fraction of baseline")
    print(f" - Average Adaptability Score: {avg_adapt:.2f}")
    print(f" - Average Sustainability Score: {avg_sustain:.2f}")
    print(f" - Average Community Wellbeing: {avg_comm:.2f} (0-1 scale)\n")
    print("===============================================================\n")

###############################################################################
# 5. DEMONSTRATION (MAIN)
###############################################################################

if __name__ == "__main__":
    # Single run demonstration (e.g., Baseline scenario)
    baseline_params = get_scenario_parameters("baseline")
    single_run_data = run_simulation(time_steps=12, param_dict=baseline_params)
    visualize_time_series(single_run_data, title="Baseline Single Run")

    # 1) Baseline Scenario
    df_baseline = run_monte_carlo(n_runs=50, time_steps=12, scenario="baseline")
    visualize_final_correlations(df_baseline, title="Baseline Final Outputs Correlation")
    stakeholder_report(df_baseline, scenario_name="Baseline")

    # 2) Optimized Resource Scenario
    df_opt_resource = run_monte_carlo(n_runs=50, time_steps=12, scenario="optimized_resource")
    visualize_final_correlations(df_opt_resource, title="Optimized Resource Scenario Correlation")
    stakeholder_report(df_opt_resource, scenario_name="Optimized Resource")

    # 3) Stress-Test Scenario
    df_stress = run_monte_carlo(n_runs=50, time_steps=12, scenario="stress_test")
    visualize_final_correlations(df_stress, title="Stress-Test Scenario Correlation")
    stakeholder_report(df_stress, scenario_name="Stress Test")

    # 4) Community Engagement Scenario
    df_community = run_monte_carlo(n_runs=50, time_steps=12, scenario="community_engagement")
    visualize_final_correlations(df_community, title="Community Engagement Correlation")
    stakeholder_report(df_community, scenario_name="Community Engagement")

    # 5) Governance Reform Scenario
    df_gov_reform = run_monte_carlo(n_runs=50, time_steps=12, scenario="governance_reform")
    visualize_final_correlations(df_gov_reform, title="Governance Reform Scenario Correlation")
    stakeholder_report(df_gov_reform, scenario_name="Governance Reform")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(style="whitegrid")
sns.set_palette(sns.color_palette("husl", 9))

###############################################################################
# SCENARIO DEFINITION (UNCHANGED)
###############################################################################

def get_scenario_parameters(scenario="baseline"):
    """
    Returns scenario-specific parameters for simulating the AI framework’s
    performance in a selected low-income city context.
    """
    if scenario == "baseline":
        # 1) Baseline Scenario
        params = {
            "population_size": (100000, 150000),
            "population_density": (2000, 3000),
            "infrastructure_quality": (0.3, 0.5),
            "resource_availability": (0.4, 0.6),

            "traffic_congestion": (0.5, 0.8),
            "energy_consumption": (1000, 2000),
            "waste_efficiency": (0.3, 0.5),
            "climate_risk": (0.2, 0.4),

            "ai_energy_opt_factor": (0.0, 0.0),
            "ai_traffic_mgmt_factor": (0.0, 0.0),
            "ai_waste_mgmt_factor": (0.0, 0.0),

            "policy_intervention_rate": (0.1, 0.2),
            "budget_allocation": (50, 100),
            "gov_quality_index": (0.3, 0.5),

            "public_participation": (0.2, 0.4),
            "feedback_loops": (0.1, 0.2),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.3, 0.5),
            "sensor_coverage": (0.2, 0.4),
            "network_bandwidth": (5, 10),
            "financial_resources": (100, 300)
        }
        return params

    elif scenario == "optimized_resource":
        # 2) Optimized Resource Scenario
        params = {
            "population_size": (120000, 180000),
            "population_density": (2500, 3500),
            "infrastructure_quality": (0.4, 0.6),
            "resource_availability": (0.5, 0.7),

            "traffic_congestion": (0.4, 0.7),
            "energy_consumption": (1200, 2200),
            "waste_efficiency": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_opt_factor": (0.02, 0.05),
            "ai_traffic_mgmt_factor": (0.02, 0.05),
            "ai_waste_mgmt_factor": (0.01, 0.04),

            "policy_intervention_rate": (0.2, 0.4),
            "budget_allocation": (100, 300),
            "gov_quality_index": (0.4, 0.6),

            "public_participation": (0.2, 0.4),
            "feedback_loops": (0.2, 0.4),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.4, 0.7),
            "sensor_coverage": (0.4, 0.6),
            "network_bandwidth": (10, 20),
            "financial_resources": (200, 500)
        }
        return params

    elif scenario == "stress_test":
        # 3) Stress-Test Scenario
        params = {
            "population_size": (100000, 150000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.3, 0.6),
            "resource_availability": (0.3, 0.5),

            "traffic_congestion": (0.5, 0.9),
            "energy_consumption": (1000, 2500),
            "waste_efficiency": (0.3, 0.6),
            "climate_risk": (0.4, 0.7),

            "ai_energy_opt_factor": (0.01, 0.03),
            "ai_traffic_mgmt_factor": (0.01, 0.03),
            "ai_waste_mgmt_factor": (0.01, 0.03),

            "policy_intervention_rate": (0.1, 0.3),
            "budget_allocation": (100, 200),
            "gov_quality_index": (0.3, 0.5),

            "public_participation": (0.1, 0.3),
            "feedback_loops": (0.1, 0.3),
            "inequality_index": (0.4, 0.6),

            "data_availability": (0.2, 0.4),
            "sensor_coverage": (0.2, 0.4),
            "network_bandwidth": (3, 8),
            "financial_resources": (100, 300)
        }
        return params

    elif scenario == "community_engagement":
        # 4) Community Engagement Scenario
        params = {
            "population_size": (100000, 150000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.4, 0.6),
            "resource_availability": (0.4, 0.6),

            "traffic_congestion": (0.4, 0.7),
            "energy_consumption": (1000, 2000),
            "waste_efficiency": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_opt_factor": (0.01, 0.04),
            "ai_traffic_mgmt_factor": (0.01, 0.04),
            "ai_waste_mgmt_factor": (0.01, 0.03),

            "policy_intervention_rate": (0.2, 0.4),
            "budget_allocation": (100, 300),
            "gov_quality_index": (0.4, 0.7),

            "public_participation": (0.4, 0.7),
            "feedback_loops": (0.4, 0.7),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.3, 0.5),
            "sensor_coverage": (0.3, 0.5),
            "network_bandwidth": (5, 10),
            "financial_resources": (100, 300)
        }
        return params

    elif scenario == "governance_reform":
        # 5) Governance Reform Scenario
        params = {
            "population_size": (100000, 160000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.4, 0.7),
            "resource_availability": (0.4, 0.7),

            "traffic_congestion": (0.4, 0.7),
            "energy_consumption": (1000, 2000),
            "waste_efficiency": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_opt_factor": (0.01, 0.03),
            "ai_traffic_mgmt_factor": (0.01, 0.04),
            "ai_waste_mgmt_factor": (0.01, 0.03),

            "policy_intervention_rate": (0.4, 0.7),
            "budget_allocation": (300, 600),
            "gov_quality_index": (0.5, 0.8),

            "public_participation": (0.2, 0.4),
            "feedback_loops": (0.2, 0.4),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.4, 0.6),
            "sensor_coverage": (0.4, 0.7),
            "network_bandwidth": (10, 20),
            "financial_resources": (300, 800)
        }
        return params

    else:
        raise ValueError(f"Unknown scenario: {scenario}")

def sample_param(range_tuple):
    """Utility to sample from a uniform distribution given a (min, max) tuple."""
    return np.random.uniform(*range_tuple)

###############################################################################
# 2. SIMULATION LOGIC (UNCHANGED)
###############################################################################

def run_simulation(time_steps=12, param_dict=None):
    """
    Simulates how an AI framework performs in a selected low-income city context.
    This code produces time series of key metrics:
      - CO2 emission reductions, commute times, waste mgmt efficiency
      - Adaptability, governance impact, sustainability, economic & community well-being
    """
    if param_dict is None:
        raise ValueError("No parameter dictionary provided for the simulation.")

    # Extract scenario-specific parameters (omitted for brevity)
    population_size     = sample_param(param_dict["population_size"])
    pop_density         = sample_param(param_dict["population_density"])
    infra_quality       = sample_param(param_dict["infrastructure_quality"])
    resource_avail      = sample_param(param_dict["resource_availability"])

    traffic_congestion  = sample_param(param_dict["traffic_congestion"])
    energy_usage        = sample_param(param_dict["energy_consumption"])
    waste_efficiency    = sample_param(param_dict["waste_efficiency"])
    climate_risk        = sample_param(param_dict["climate_risk"])

    ai_energy_factor    = sample_param(param_dict["ai_energy_opt_factor"])
    ai_traffic_factor   = sample_param(param_dict["ai_traffic_mgmt_factor"])
    ai_waste_factor     = sample_param(param_dict["ai_waste_mgmt_factor"])

    policy_rate         = sample_param(param_dict["policy_intervention_rate"])
    budget_alloc        = sample_param(param_dict["budget_allocation"])
    gov_quality         = sample_param(param_dict["gov_quality_index"])

    participation       = sample_param(param_dict["public_participation"])
    feedback            = sample_param(param_dict["feedback_loops"])
    inequality_index    = sample_param(param_dict["inequality_index"])

    data_avail          = sample_param(param_dict["data_availability"])
    sensor_coverage     = sample_param(param_dict["sensor_coverage"])
    bandwidth           = sample_param(param_dict["network_bandwidth"])
    finances            = sample_param(param_dict["financial_resources"])

    # Initialize states
    co2_reduction_ts          = []
    commute_time_ts           = []
    waste_mgmt_ts            = []
    adaptability_ts           = []
    gov_impact_ts             = []
    sustainability_ts         = []
    econ_impact_ts            = []
    community_wellbeing_ts    = []

    current_co2_reduction   = 0.0
    current_commute_time    = 30.0
    current_waste_effic     = waste_efficiency
    current_adaptability    = 0.2
    current_gov_impact      = gov_quality
    current_sustainability  = 0.3
    current_econ_impact     = 0.0
    current_community_score = 0.4

    for t in range(time_steps):
        # AI improvements in energy, traffic, waste
        energy_opt_gain  = ai_energy_factor   * data_avail * sensor_coverage
        traffic_opt_gain = ai_traffic_factor  * data_avail * sensor_coverage
        waste_opt_gain   = ai_waste_factor    * data_avail * sensor_coverage

        # CO2 Reduction
        finance_limit = max(1.0, (1.0 - finances * 0.001))
        climate_loss  = climate_risk * 0.02
        current_co2_reduction += (energy_opt_gain * 0.02) - climate_loss - finance_limit*0.0001
        current_co2_reduction = max(0, min(1.0, current_co2_reduction))
        co2_reduction_ts.append(current_co2_reduction)

        # Commute Times
        infra_bonus  = infra_quality * 0.01
        pop_density_penalty = pop_density * 0.0001
        current_commute_time -= (traffic_opt_gain * 0.5) + (infra_bonus*2)
        current_commute_time += pop_density_penalty
        current_commute_time = max(5.0, current_commute_time)
        commute_time_ts.append(current_commute_time)

        # Waste Management Efficiency
        current_waste_effic += (waste_opt_gain * 0.01) - (inequality_index * 0.001)
        current_waste_effic = max(0, min(1.0, current_waste_effic))
        waste_mgmt_ts.append(current_waste_effic)

        # Adaptability
        constraint_factor = data_avail + sensor_coverage + (finances*0.001)
        gov_community_boost = policy_rate + participation + feedback
        current_adaptability += (constraint_factor * 0.001) + (gov_community_boost * 0.001)
        current_adaptability = max(0, min(1.0, current_adaptability))
        adaptability_ts.append(current_adaptability)

        # Governance Impact
        gov_improve = (gov_quality * 0.01) + (feedback * 0.01)
        current_gov_impact += gov_improve - climate_risk*0.001
        current_gov_impact = max(0, min(1.0, current_gov_impact))
        gov_impact_ts.append(current_gov_impact)

        # Sustainability
        resource_gain = resource_avail * 0.01
        climate_penalty = climate_risk * 0.003
        current_sustainability += (energy_opt_gain + traffic_opt_gain)*0.01 + resource_gain - climate_penalty
        current_sustainability = max(0, min(1.0, current_sustainability))
        sustainability_ts.append(current_sustainability)

        # Economic & Community Impact
        cost_savings = (energy_opt_gain + traffic_opt_gain + waste_opt_gain)*100
        community_boost = (participation + feedback)*0.5
        current_econ_impact += cost_savings*0.01
        current_community_score += community_boost*0.001
        current_community_score = max(0, min(1.0, current_community_score))

        econ_impact_ts.append(current_econ_impact)
        community_wellbeing_ts.append(current_community_score)

    return {
        "CO2_Reduction_TS": co2_reduction_ts,
        "Commute_Time_TS": commute_time_ts,
        "Waste_Mgmt_Efficiency_TS": waste_mgmt_ts,
        "Adaptability_TS": adaptability_ts,
        "Gov_Impact_TS": gov_impact_ts,
        "Sustainability_TS": sustainability_ts,
        "Econ_Impact_TS": econ_impact_ts,
        "Community_Wellbeing_TS": community_wellbeing_ts
    }

###############################################################################
# 3. MONTE CARLO SIMULATION (UNCHANGED)
###############################################################################

def run_monte_carlo(n_runs=50, time_steps=12, scenario="baseline"):
    scenario_ranges = get_scenario_parameters(scenario)
    final_results = {
        "CO2_Reduction": [],
        "Commute_Time": [],
        "Waste_Mgmt_Efficiency": [],
        "Adaptability": [],
        "Gov_Impact": [],
        "Sustainability": [],
        "Econ_Impact": [],
        "Community_Wellbeing": []
    }

    for _ in range(n_runs):
        sim_data = run_simulation(time_steps=time_steps, param_dict=scenario_ranges)
        final_results["CO2_Reduction"].append(sim_data["CO2_Reduction_TS"][-1])
        final_results["Commute_Time"].append(sim_data["Commute_Time_TS"][-1])
        final_results["Waste_Mgmt_Efficiency"].append(sim_data["Waste_Mgmt_Efficiency_TS"][-1])
        final_results["Adaptability"].append(sim_data["Adaptability_TS"][-1])
        final_results["Gov_Impact"].append(sim_data["Gov_Impact_TS"][-1])
        final_results["Sustainability"].append(sim_data["Sustainability_TS"][-1])
        final_results["Econ_Impact"].append(sim_data["Econ_Impact_TS"][-1])
        final_results["Community_Wellbeing"].append(sim_data["Community_Wellbeing_TS"][-1])

    df_final = pd.DataFrame(final_results)
    return df_final

###############################################################################
# 4. VISUALIZATION & STAKEHOLDER REPORT (UNCHANGED)
###############################################################################

def visualize_time_series(sim_data, title="Simulation Time Series"):
    df = pd.DataFrame({
        "CO2_Reduction": sim_data["CO2_Reduction_TS"],
        "Commute_Time": sim_data["Commute_Time_TS"],
        "Waste_Mgmt_Efficiency": sim_data["Waste_Mgmt_Efficiency_TS"],
        "Adaptability": sim_data["Adaptability_TS"],
        "Gov_Impact": sim_data["Gov_Impact_TS"],
        "Sustainability": sim_data["Sustainability_TS"],
        "Econ_Impact": sim_data["Econ_Impact_TS"],
        "Community_Wellbeing": sim_data["Community_Wellbeing_TS"]
    })
    df.plot(subplots=True, figsize=(12,12), layout=(4,2), sharex=True)
    plt.suptitle(title)
    plt.tight_layout()
    plt.show()

def visualize_final_correlations(df_results, title="Final Step Correlation"):
    corr_matrix = df_results.corr()
    plt.figure(figsize=(8, 6))
    sns.heatmap(corr_matrix, annot=True, cmap="viridis", fmt=".2f")
    plt.title(title)
    plt.tight_layout()
    plt.show()

def stakeholder_report(df_results, scenario_name="Baseline"):
    print(f"\n===== {scenario_name.upper()} SCENARIO - STAKEHOLDER REPORT =====")
    summary_stats = df_results.describe(percentiles=[0.1, 0.5, 0.9])
    print(summary_stats)

    avg_co2    = df_results["CO2_Reduction"].mean()
    avg_adapt  = df_results["Adaptability"].mean()
    avg_sustain= df_results["Sustainability"].mean()
    avg_comm   = df_results["Community_Wellbeing"].mean()

    print("\nKey Highlights:")
    print(f" - Average CO2 Reduction: {avg_co2:.2f} fraction of baseline")
    print(f" - Average Adaptability Score: {avg_adapt:.2f}")
    print(f" - Average Sustainability Score: {avg_sustain:.2f}")
    print(f" - Average Community Wellbeing: {avg_comm:.2f} (0-1 scale)\n")
    print("===============================================================\n")

###############################################################################
# 5. RELIABILITY AND VALIDITY TESTS (NEW)
###############################################################################

def test_reliability(scenario="baseline", time_steps=12, n_runs=50, tolerance=0.05):
    """
    Tests how consistent (reliable) the simulation is across repeated runs.
    Approach:
      - Run the scenario multiple times.
      - Measure standard deviation (or coefficient of variation) of final outputs.
      - If below a chosen tolerance, we consider it 'reliable'.
    Returns a dict of reliability scores for each metric.
    """
    df_results = run_monte_carlo(n_runs=n_runs, time_steps=time_steps, scenario=scenario)

    # For a naive approach, let's measure the ratio (std / mean) or just std
    reliability_scores = {}
    for col in df_results.columns:
        mean_val = df_results[col].mean()
        std_val  = df_results[col].std()
        if mean_val != 0:
            ratio = std_val / mean_val
        else:
            ratio = std_val
        reliability_scores[col] = ratio

    # Print or interpret these results
    print(f"\n=== RELIABILITY TEST for scenario '{scenario}' ===")
    for metric, score in reliability_scores.items():
        status = "PASS" if score < tolerance else "FAIL"
        print(f"{metric}: Ratio={score:.4f}, Tolerance={tolerance} => {status}")
    print("=================================================\n")

    return reliability_scores

def test_validity(scenario="baseline", time_steps=12, n_runs=50, real_data_df=None):
    """
    Tests how well the simulation matches real-world (or historically known) data.
    Approach:
      - Run the scenario multiple times to get an averaged result for final outputs.
      - Compare with 'real_data_df' or 'historical_baseline_df' to measure closeness
        (e.g., correlation or mean absolute difference).
    real_data_df: a DataFrame with known reference values for each metric
                  columns: ["CO2_Reduction", "Commute_Time", ...] etc.
    Returns a dict with validity scores or correlation measures.
    """
    if real_data_df is None:
        print("No real-world data provided for validity test. Skipping.")
        return None

    df_sim_results = run_monte_carlo(n_runs=n_runs, time_steps=time_steps, scenario=scenario)
    df_mean = df_sim_results.mean()  # average final values from the simulation

    # We'll do a naive measure of difference or correlation
    validity_scores = {}
    for col in df_mean.index:
        if col in real_data_df.columns:
            # E.g., difference-based measure
            sim_val  = df_mean[col]
            real_val = real_data_df[col].iloc[0]  # assume single row or representative value
            diff     = abs(sim_val - real_val)
            validity_scores[col] = diff
        else:
            validity_scores[col] = np.nan

    print(f"\n=== VALIDITY TEST for scenario '{scenario}' ===")
    print("Comparing average simulation results to real-world data:")
    for metric, diff_val in validity_scores.items():
        print(f"{metric}: Absolute Difference = {diff_val}")
    print("=================================================\n")

    return validity_scores

###############################################################################
# 6. DEMONSTRATION (MAIN)
###############################################################################

if __name__ == "__main__":
    # EXAMPLE: Baseline single run
    baseline_params = get_scenario_parameters("baseline")
    single_run_data = run_simulation(time_steps=12, param_dict=baseline_params)
    visualize_time_series(single_run_data, title="Baseline Single Run")

    # Monte Carlo for Baseline
    df_baseline = run_monte_carlo(n_runs=50, time_steps=12, scenario="baseline")
    visualize_final_correlations(df_baseline, title="Baseline Final Outputs Correlation")
    stakeholder_report(df_baseline, scenario_name="Baseline")

    # RELIABILITY TEST
    # e.g., we accept ratio (std/mean) < 0.05 as "PASS"
    test_reliability(scenario="baseline", tolerance=0.05)

    # VALIDITY TEST
    # In practice, you'd load 'real_data_df' from CSV or database. We'll create a dummy DF here:
    real_data_example = pd.DataFrame({
        "CO2_Reduction": [0.05],     # Suppose real data shows 5% CO2 reduction
        "Commute_Time": [25.0],      # Real world average commute is 25 minutes
        "Waste_Mgmt_Efficiency": [0.45],
        "Adaptability": [0.3],
        "Gov_Impact": [0.4],
        "Sustainability": [0.5],
        "Econ_Impact": [1.5],
        "Community_Wellbeing": [0.45]
    })

    test_validity(scenario="baseline", real_data_df=real_data_example)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(style="whitegrid")
sns.set_palette(sns.color_palette("husl", 9))

###############################################################################
# 1. SCENARIO DEFINITION
###############################################################################

def get_scenario_parameters(scenario="baseline"):
    """
    Returns scenario-specific parameters for simulating the AI framework’s
    performance in a selected low-income city context, based on real or modeled data.
    """
    if scenario == "baseline":
        # 1) Baseline Scenario
        #    Reflects the city's current state without major AI interventions.
        return {
            # City-Specific Data
            "population_size": (100000, 150000),
            "population_density": (2000, 3000),
            "infrastructure_quality": (0.3, 0.5),
            "resource_availability": (0.4, 0.6),

            # Urban Challenges
            "traffic_congestion": (0.4, 0.7),
            "energy_consumption": (800, 1500),
            "waste_management_eff": (0.3, 0.5),
            "climate_risk": (0.2, 0.4),

            # AI Framework Parameters
            "ai_energy_factor": (0.0, 0.0),
            "ai_traffic_factor": (0.0, 0.0),
            "ai_waste_factor": (0.0, 0.0),

            # Governance Inputs
            "policy_rate": (0.1, 0.2),
            "budget_alloc": (50, 100),
            "gov_quality_score": (0.3, 0.5),

            # Community Factors
            "public_participation": (0.2, 0.4),
            "community_feedback": (0.1, 0.3),
            "inequality_index": (0.3, 0.5),

            # Performance Constraints
            "data_availability": (0.3, 0.5),
            "sensor_coverage": (0.2, 0.4),
            "network_bandwidth": (5, 10),
            "financial_resources": (100, 300)
        }

    elif scenario == "optimized_resource":
        # 2) Optimized Resource Scenario
        #    Tests the framework with advanced AI solutions in energy, transport, waste management.
        return {
            "population_size": (120000, 180000),
            "population_density": (2500, 3500),
            "infrastructure_quality": (0.4, 0.6),
            "resource_availability": (0.5, 0.7),

            "traffic_congestion": (0.3, 0.6),
            "energy_consumption": (1000, 2000),
            "waste_management_eff": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_factor": (0.02, 0.05),
            "ai_traffic_factor": (0.02, 0.05),
            "ai_waste_factor": (0.01, 0.04),

            "policy_rate": (0.2, 0.4),
            "budget_alloc": (100, 300),
            "gov_quality_score": (0.4, 0.6),

            "public_participation": (0.2, 0.4),
            "community_feedback": (0.2, 0.4),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.4, 0.7),
            "sensor_coverage": (0.4, 0.6),
            "network_bandwidth": (10, 20),
            "financial_resources": (200, 500)
        }

    elif scenario == "stress_test":
        # 3) Stress-Test Scenario
        #    Introduces extreme events (floods, grid failures, traffic surges).
        return {
            "population_size": (100000, 150000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.3, 0.6),
            "resource_availability": (0.3, 0.5),

            "traffic_congestion": (0.5, 0.9),
            "energy_consumption": (800, 2000),
            "waste_management_eff": (0.3, 0.5),
            "climate_risk": (0.4, 0.7),  # Higher climate risk

            "ai_energy_factor": (0.01, 0.03),
            "ai_traffic_factor": (0.01, 0.03),
            "ai_waste_factor": (0.01, 0.03),

            "policy_rate": (0.1, 0.3),
            "budget_alloc": (100, 200),
            "gov_quality_score": (0.3, 0.5),

            "public_participation": (0.1, 0.3),
            "community_feedback": (0.1, 0.3),
            "inequality_index": (0.4, 0.6),

            "data_availability": (0.2, 0.4),
            "sensor_coverage": (0.2, 0.4),
            "network_bandwidth": (3, 8),
            "financial_resources": (100, 300)
        }

    elif scenario == "community_engagement":
        # 4) Community Engagement Scenario
        #    Enhanced public participation and feedback loops.
        return {
            "population_size": (100000, 150000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.4, 0.6),
            "resource_availability": (0.4, 0.6),

            "traffic_congestion": (0.3, 0.6),
            "energy_consumption": (800, 1500),
            "waste_management_eff": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_factor": (0.01, 0.04),
            "ai_traffic_factor": (0.01, 0.04),
            "ai_waste_factor": (0.01, 0.03),

            "policy_rate": (0.2, 0.4),
            "budget_alloc": (100, 300),
            "gov_quality_score": (0.4, 0.7),

            "public_participation": (0.4, 0.7),
            "community_feedback": (0.3, 0.6),  # Higher feedback loops
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.3, 0.5),
            "sensor_coverage": (0.3, 0.5),
            "network_bandwidth": (5, 10),
            "financial_resources": (100, 300)
        }

    elif scenario == "governance_reform":
        # 5) Governance Reform Scenario
        #    Improved governance inputs (e.g., budget allocation, policy responsiveness).
        return {
            "population_size": (100000, 160000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.4, 0.7),
            "resource_availability": (0.4, 0.7),

            "traffic_congestion": (0.3, 0.6),
            "energy_consumption": (800, 1500),
            "waste_management_eff": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_factor": (0.01, 0.03),
            "ai_traffic_factor": (0.01, 0.04),
            "ai_waste_factor": (0.01, 0.03),

            "policy_rate": (0.4, 0.7),    # More active governance
            "budget_alloc": (300, 600),  # Larger budgets
            "gov_quality_score": (0.5, 0.8),

            "public_participation": (0.2, 0.4),
            "community_feedback": (0.2, 0.4),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.4, 0.6),
            "sensor_coverage": (0.4, 0.7),
            "network_bandwidth": (10, 20),
            "financial_resources": (300, 800)
        }

    else:
        raise ValueError(f"Unknown scenario: {scenario}")

def sample_param(range_tuple):
    """Utility: sample from uniform(min, max)."""
    return np.random.uniform(*range_tuple)

###############################################################################
# 2. SIMULATION LOGIC
###############################################################################

def run_simulation(time_steps=12, scenario_params=None):
    """
    Simulates how an AI framework performs in a selected low-income city context,
    producing time series of:
      - Framework Performance (CO2 reduction, commute times, waste efficiency)
      - Adaptability
      - Governance Impact
      - Sustainability
      - Economic Impact
      - Community Well-Being
    """

    if scenario_params is None:
        scenario_params = get_scenario_parameters("baseline")

    # 2.1: DRAW PARAMETERS (City-Specific Data, Urban Challenges, etc.)
    population_size   = sample_param(scenario_params["population_size"])
    pop_density       = sample_param(scenario_params["population_density"])
    infra_quality     = sample_param(scenario_params["infrastructure_quality"])
    resource_avail    = sample_param(scenario_params["resource_availability"])

    traffic_congestion = sample_param(scenario_params["traffic_congestion"])
    energy_usage       = sample_param(scenario_params["energy_consumption"])
    waste_eff          = sample_param(scenario_params["waste_management_eff"])
    climate_risk       = sample_param(scenario_params["climate_risk"])

    # AI Framework
    ai_energy          = sample_param(scenario_params["ai_energy_factor"])
    ai_traffic         = sample_param(scenario_params["ai_traffic_factor"])
    ai_waste           = sample_param(scenario_params["ai_waste_factor"])

    # Governance
    policy_rate        = sample_param(scenario_params["policy_rate"])
    budget_alloc       = sample_param(scenario_params["budget_alloc"])
    gov_quality        = sample_param(scenario_params["gov_quality_score"])

    # Community
    participation      = sample_param(scenario_params["public_participation"])
    community_feed     = sample_param(scenario_params["community_feedback"])
    inequality_ind     = sample_param(scenario_params["inequality_index"])

    # Constraints
    data_avail         = sample_param(scenario_params["data_availability"])
    sensor_cover       = sample_param(scenario_params["sensor_coverage"])
    bandwidth          = sample_param(scenario_params["network_bandwidth"])
    finances           = sample_param(scenario_params["financial_resources"])

    # 2.2: TIME SERIES ARRAYS
    performance_list = []
    adaptability_list = []
    gov_impact_list = []
    sustainability_list = []
    econ_impact_list = []
    community_list = []

    # 2.3: INITIAL STATES
    co2_reduction      = 0.0   # fraction of baseline CO2 reduced
    commute_time       = 30.0  # baseline minutes
    waste_mgmt_eff     = waste_eff
    adapt_score        = 0.2   # how well the AI adapts to constraints
    gov_score          = gov_quality
    sustain_score      = 0.3
    econ_score         = 0.0   # cost savings or productivity
    community_score    = 0.4   # well-being or satisfaction

    for t in range(time_steps):
        # AI performance => reduce CO2, commute times, etc.
        # Weighted by data availability, sensor coverage, etc.
        energy_gain   = ai_energy * data_avail * sensor_cover
        traffic_gain  = ai_traffic * data_avail * sensor_cover
        waste_gain    = ai_waste   * data_avail * sensor_cover

        # FRAMEWORK PERFORMANCE
        # e.g., CO2 reduced by (energy_gain), commute down by (traffic_gain)
        co2_reduction += energy_gain * 0.01
        co2_reduction  = max(0, min(1.0, co2_reduction))

        commute_time -= (traffic_gain * 0.5)
        commute_time  = max(5.0, commute_time)

        # waste mgmt improvement
        waste_mgmt_eff += (waste_gain * 0.01) - (inequality_ind * 0.001)
        waste_mgmt_eff  = max(0, min(1.0, waste_mgmt_eff))

        # Put it all into a single "Framework Performance" metric
        # e.g., average of these sub-dimensions
        performance_metric = (
            co2_reduction
            + (30.0 - commute_time) / 30.0
            + waste_mgmt_eff
        ) / 3.0
        performance_list.append(performance_metric)

        # ADAPTABILITY
        # e.g., how many constraints we handle
        constraint_factor = data_avail + sensor_cover + (finances*0.001)
        adapt_score += (constraint_factor * 0.001) + (policy_rate * 0.001)
        adapt_score  = max(0, min(1.0, adapt_score))
        adaptability_list.append(adapt_score * 100)  # % of variables optimized

        # GOVERNANCE IMPACT
        # e.g., reduce policy response time or improve governance score
        gov_score += (policy_rate * 0.01) + (community_feed * 0.01)
        gov_score  = max(0, min(1.0, gov_score))
        gov_impact_list.append(gov_score * 100)  # scaled to 0-100

        # SUSTAINABILITY
        # e.g., combine renewable usage, air quality improvements
        # Here, we approximate with co2_reduction + resource_avail
        sustain_score += (co2_reduction*0.01) + (resource_avail*0.001)
        sustain_score  = max(0, min(1.0, sustain_score))
        sustainability_list.append(sustain_score * 100)

        # ECONOMIC IMPACT
        # e.g., cost savings from improved traffic, energy usage
        econ_score += (traffic_gain + energy_gain)*10
        econ_impact_list.append(econ_score)

        # COMMUNITY WELL-BEING
        # e.g., participation + improved waste mgmt => satisfaction
        community_score += participation*0.001 + (waste_gain*0.0005)
        community_score  = max(0, min(1.0, community_score))
        community_list.append(community_score * 100)

    return {
        "Framework_Performance": performance_list,
        "Adaptability": adaptability_list,
        "Gov_Impact": gov_impact_list,
        "Sustainability": sustainability_list,
        "Econ_Impact": econ_impact_list,
        "Community_WellBeing": community_list
    }

###############################################################################
# 3. MONTE CARLO SIMULATION
###############################################################################

def run_monte_carlo(n_runs=50, time_steps=12, scenario="baseline"):
    """
    Runs multiple simulations for the selected city scenario, storing the final step
    of each run for analysis.
    """
    scenario_params = get_scenario_parameters(scenario)
    final_results = {
        "Framework_Performance": [],
        "Adaptability": [],
        "Gov_Impact": [],
        "Sustainability": [],
        "Econ_Impact": [],
        "Community_WellBeing": []
    }

    for _ in range(n_runs):
        sim_data = run_simulation(time_steps=time_steps, scenario_params=scenario_params)
        # Grab final step
        final_results["Framework_Performance"].append(sim_data["Framework_Performance"][-1])
        final_results["Adaptability"].append(sim_data["Adaptability"][-1])
        final_results["Gov_Impact"].append(sim_data["Gov_Impact"][-1])
        final_results["Sustainability"].append(sim_data["Sustainability"][-1])
        final_results["Econ_Impact"].append(sim_data["Econ_Impact"][-1])
        final_results["Community_WellBeing"].append(sim_data["Community_WellBeing"][-1])

    return pd.DataFrame(final_results)

###############################################################################
# 4. VISUALIZATION & REPORT
###############################################################################

def visualize_time_series(sim_data, title="Single Run Time Series"):
    """
    Plots the time series for the 6 key metrics in one run.
    """
    df = pd.DataFrame({
        "Framework_Performance": sim_data["Framework_Performance"],
        "Adaptability": sim_data["Adaptability"],
        "Gov_Impact": sim_data["Gov_Impact"],
        "Sustainability": sim_data["Sustainability"],
        "Econ_Impact": sim_data["Econ_Impact"],
        "Community_WellBeing": sim_data["Community_WellBeing"]
    })

    df.plot(subplots=True, figsize=(10,10), layout=(3,2), sharex=True)
    plt.suptitle(title)
    plt.tight_layout()
    plt.show()

def analyze_scenario_results(df_results, scenario_name="Baseline"):
    """
    Prints summary stats and plots histograms for the final-step distribution
    of each metric under Monte Carlo simulations.
    """
    print(f"\n=== {scenario_name.upper()} SCENARIO RESULTS ===")
    summary_stats = df_results.describe(percentiles=[0.025, 0.5, 0.975])
    print(summary_stats)

    columns = df_results.columns
    fig, axes = plt.subplots(2, 3, figsize=(12, 8))
    axes = axes.flatten()
    for i, col in enumerate(columns):
        sns.histplot(df_results[col], kde=True, ax=axes[i])
        axes[i].set_title(col)

    plt.suptitle(f"{scenario_name.title()} Scenario - Final Step Distribution")
    plt.tight_layout()
    plt.show()

###############################################################################
# 5. MAIN (DEMONSTRATION)
###############################################################################

if __name__ == "__main__":
    # SCENARIOS FOR RQ4
    scenarios = [
        "baseline",
        "optimized_resource",
        "stress_test",
        "community_engagement",
        "governance_reform"
    ]

    for scenario in scenarios:
        print(f"\n--- RUNNING SCENARIO: {scenario} ---")

        # (A) Single run time series
        scenario_params = get_scenario_parameters(scenario)
        single_run_output = run_simulation(time_steps=12, scenario_params=scenario_params)
        visualize_time_series(single_run_output, title=f"{scenario.title()} - Single Run Time Series")

        # (B) Monte Carlo final distribution
        df_final = run_monte_carlo(n_runs=50, time_steps=12, scenario=scenario)
        analyze_scenario_results(df_final, scenario_name=scenario)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(style="whitegrid")
sns.set_palette(sns.color_palette("husl", 9))

###############################################################################
# 1. SCENARIO DEFINITION
###############################################################################

def get_scenario_parameters(scenario="baseline"):
    """
    Returns scenario-specific parameters for simulating the AI framework’s
    performance in a selected low-income city context, based on real or modeled data.
    """
    if scenario == "baseline":
        # 1) Baseline Scenario
        #    Reflects the city's current state without major AI interventions.
        return {
            # City-Specific Data
            "population_size": (100000, 150000),
            "population_density": (2000, 3000),
            "infrastructure_quality": (0.3, 0.5),
            "resource_availability": (0.4, 0.6),

            # Urban Challenges
            "traffic_congestion": (0.4, 0.7),
            "energy_consumption": (800, 1500),
            "waste_management_eff": (0.3, 0.5),
            "climate_risk": (0.2, 0.4),

            # AI Framework Parameters
            "ai_energy_factor": (0.0, 0.0),
            "ai_traffic_factor": (0.0, 0.0),
            "ai_waste_factor": (0.0, 0.0),

            # Governance Inputs
            "policy_rate": (0.1, 0.2),
            "budget_alloc": (50, 100),
            "gov_quality_score": (0.3, 0.5),

            # Community Factors
            "public_participation": (0.2, 0.4),
            "community_feedback": (0.1, 0.3),
            "inequality_index": (0.3, 0.5),

            # Performance Constraints
            "data_availability": (0.3, 0.5),
            "sensor_coverage": (0.2, 0.4),
            "network_bandwidth": (5, 10),
            "financial_resources": (100, 300)
        }

    elif scenario == "optimized_resource":
        # 2) Optimized Resource Scenario
        #    Tests the framework with advanced AI solutions in energy, transport, waste management.
        return {
            "population_size": (120000, 180000),
            "population_density": (2500, 3500),
            "infrastructure_quality": (0.4, 0.6),
            "resource_availability": (0.5, 0.7),

            "traffic_congestion": (0.3, 0.6),
            "energy_consumption": (1000, 2000),
            "waste_management_eff": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_factor": (0.02, 0.05),
            "ai_traffic_factor": (0.02, 0.05),
            "ai_waste_factor": (0.01, 0.04),

            "policy_rate": (0.2, 0.4),
            "budget_alloc": (100, 300),
            "gov_quality_score": (0.4, 0.6),

            "public_participation": (0.2, 0.4),
            "community_feedback": (0.2, 0.4),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.4, 0.7),
            "sensor_coverage": (0.4, 0.6),
            "network_bandwidth": (10, 20),
            "financial_resources": (200, 500)
        }

    elif scenario == "stress_test":
        # 3) Stress-Test Scenario
        #    Introduces extreme events (floods, grid failures, traffic surges).
        return {
            "population_size": (100000, 150000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.3, 0.6),
            "resource_availability": (0.3, 0.5),

            "traffic_congestion": (0.5, 0.9),
            "energy_consumption": (800, 2000),
            "waste_management_eff": (0.3, 0.5),
            "climate_risk": (0.4, 0.7),  # Higher climate risk

            "ai_energy_factor": (0.01, 0.03),
            "ai_traffic_factor": (0.01, 0.03),
            "ai_waste_factor": (0.01, 0.03),

            "policy_rate": (0.1, 0.3),
            "budget_alloc": (100, 200),
            "gov_quality_score": (0.3, 0.5),

            "public_participation": (0.1, 0.3),
            "community_feedback": (0.1, 0.3),
            "inequality_index": (0.4, 0.6),

            "data_availability": (0.2, 0.4),
            "sensor_coverage": (0.2, 0.4),
            "network_bandwidth": (3, 8),
            "financial_resources": (100, 300)
        }

    elif scenario == "community_engagement":
        # 4) Community Engagement Scenario
        #    Enhanced public participation and feedback loops.
        return {
            "population_size": (100000, 150000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.4, 0.6),
            "resource_availability": (0.4, 0.6),

            "traffic_congestion": (0.3, 0.6),
            "energy_consumption": (800, 1500),
            "waste_management_eff": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_factor": (0.01, 0.04),
            "ai_traffic_factor": (0.01, 0.04),
            "ai_waste_factor": (0.01, 0.03),

            "policy_rate": (0.2, 0.4),
            "budget_alloc": (100, 300),
            "gov_quality_score": (0.4, 0.7),

            "public_participation": (0.4, 0.7),
            "community_feedback": (0.3, 0.6),  # Higher feedback loops
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.3, 0.5),
            "sensor_coverage": (0.3, 0.5),
            "network_bandwidth": (5, 10),
            "financial_resources": (100, 300)
        }

    elif scenario == "governance_reform":
        # 5) Governance Reform Scenario
        #    Improved governance inputs (e.g., budget allocation, policy responsiveness).
        return {
            "population_size": (100000, 160000),
            "population_density": (2000, 4000),
            "infrastructure_quality": (0.4, 0.7),
            "resource_availability": (0.4, 0.7),

            "traffic_congestion": (0.3, 0.6),
            "energy_consumption": (800, 1500),
            "waste_management_eff": (0.4, 0.6),
            "climate_risk": (0.2, 0.4),

            "ai_energy_factor": (0.01, 0.03),
            "ai_traffic_factor": (0.01, 0.04),
            "ai_waste_factor": (0.01, 0.03),

            "policy_rate": (0.4, 0.7),    # More active governance
            "budget_alloc": (300, 600),  # Larger budgets
            "gov_quality_score": (0.5, 0.8),

            "public_participation": (0.2, 0.4),
            "community_feedback": (0.2, 0.4),
            "inequality_index": (0.3, 0.5),

            "data_availability": (0.4, 0.6),
            "sensor_coverage": (0.4, 0.7),
            "network_bandwidth": (10, 20),
            "financial_resources": (300, 800)
        }

    else:
        raise ValueError(f"Unknown scenario: {scenario}")

def sample_param(range_tuple):
    """Utility: sample from uniform(min, max)."""
    return np.random.uniform(*range_tuple)

###############################################################################
# 2. SIMULATION LOGIC
###############################################################################

def run_simulation(time_steps=12, scenario_params=None):
    """
    Simulates how an AI framework performs in a selected low-income city context,
    producing time series of:
      - Framework Performance (CO2 reduction, commute times, waste efficiency)
      - Adaptability
      - Governance Impact
      - Sustainability
      - Economic Impact
      - Community Well-Being
    """

    if scenario_params is None:
        scenario_params = get_scenario_parameters("baseline")

    # 2.1: DRAW PARAMETERS (City-Specific Data, Urban Challenges, etc.)
    population_size   = sample_param(scenario_params["population_size"])
    pop_density       = sample_param(scenario_params["population_density"])
    infra_quality     = sample_param(scenario_params["infrastructure_quality"])
    resource_avail    = sample_param(scenario_params["resource_availability"])

    traffic_congestion = sample_param(scenario_params["traffic_congestion"])
    energy_usage       = sample_param(scenario_params["energy_consumption"])
    waste_eff          = sample_param(scenario_params["waste_management_eff"])
    climate_risk       = sample_param(scenario_params["climate_risk"])

    # AI Framework
    ai_energy          = sample_param(scenario_params["ai_energy_factor"])
    ai_traffic         = sample_param(scenario_params["ai_traffic_factor"])
    ai_waste           = sample_param(scenario_params["ai_waste_factor"])

    # Governance
    policy_rate        = sample_param(scenario_params["policy_rate"])
    budget_alloc       = sample_param(scenario_params["budget_alloc"])
    gov_quality        = sample_param(scenario_params["gov_quality_score"])

    # Community
    participation      = sample_param(scenario_params["public_participation"])
    community_feed     = sample_param(scenario_params["community_feedback"])
    inequality_ind     = sample_param(scenario_params["inequality_index"])

    # Constraints
    data_avail         = sample_param(scenario_params["data_availability"])
    sensor_cover       = sample_param(scenario_params["sensor_coverage"])
    bandwidth          = sample_param(scenario_params["network_bandwidth"])
    finances           = sample_param(scenario_params["financial_resources"])

    # 2.2: TIME SERIES ARRAYS
    performance_list = []
    adaptability_list = []
    gov_impact_list = []
    sustainability_list = []
    econ_impact_list = []
    community_list = []

    # 2.3: INITIAL STATES
    co2_reduction      = 0.0   # fraction of baseline CO2 reduced
    commute_time       = 30.0  # baseline minutes
    waste_mgmt_eff     = waste_eff
    adapt_score        = 0.2   # how well the AI adapts to constraints
    gov_score          = gov_quality
    sustain_score      = 0.3
    econ_score         = 0.0   # cost savings or productivity
    community_score    = 0.4   # well-being or satisfaction

    for t in range(time_steps):
        # AI performance => reduce CO2, commute times, etc.
        # Weighted by data availability, sensor coverage, etc.
        energy_gain   = ai_energy * data_avail * sensor_cover
        traffic_gain  = ai_traffic * data_avail * sensor_cover
        waste_gain    = ai_waste   * data_avail * sensor_cover

        # FRAMEWORK PERFORMANCE
        # e.g., CO2 reduced by (energy_gain), commute down by (traffic_gain)
        co2_reduction += energy_gain * 0.01
        co2_reduction  = max(0, min(1.0, co2_reduction))

        commute_time -= (traffic_gain * 0.5)
        commute_time  = max(5.0, commute_time)

        # waste mgmt improvement
        waste_mgmt_eff += (waste_gain * 0.01) - (inequality_ind * 0.001)
        waste_mgmt_eff  = max(0, min(1.0, waste_mgmt_eff))

        # Put it all into a single "Framework Performance" metric
        # e.g., average of these sub-dimensions
        performance_metric = (
            co2_reduction
            + (30.0 - commute_time) / 30.0
            + waste_mgmt_eff
        ) / 3.0
        performance_list.append(performance_metric)

        # ADAPTABILITY
        # e.g., how many constraints we handle
        constraint_factor = data_avail + sensor_cover + (finances*0.001)
        adapt_score += (constraint_factor * 0.001) + (policy_rate * 0.001)
        adapt_score  = max(0, min(1.0, adapt_score))
        adaptability_list.append(adapt_score * 100)  # % of variables optimized

        # GOVERNANCE IMPACT
        # e.g., reduce policy response time or improve governance score
        gov_score += (policy_rate * 0.01) + (community_feed * 0.01)
        gov_score  = max(0, min(1.0, gov_score))
        gov_impact_list.append(gov_score * 100)  # scaled to 0-100

        # SUSTAINABILITY
        # e.g., combine renewable usage, air quality improvements
        # Here, we approximate with co2_reduction + resource_avail
        sustain_score += (co2_reduction*0.01) + (resource_avail*0.001)
        sustain_score  = max(0, min(1.0, sustain_score))
        sustainability_list.append(sustain_score * 100)

        # ECONOMIC IMPACT
        # e.g., cost savings from improved traffic, energy usage
        econ_score += (traffic_gain + energy_gain)*10
        econ_impact_list.append(econ_score)

        # COMMUNITY WELL-BEING
        # e.g., participation + improved waste mgmt => satisfaction
        community_score += participation*0.001 + (waste_gain*0.0005)
        community_score  = max(0, min(1.0, community_score))
        community_list.append(community_score * 100)

    return {
        "Framework_Performance": performance_list,
        "Adaptability": adaptability_list,
        "Gov_Impact": gov_impact_list,
        "Sustainability": sustainability_list,
        "Econ_Impact": econ_impact_list,
        "Community_WellBeing": community_list
    }

###############################################################################
# 3. MONTE CARLO SIMULATION
###############################################################################

def run_monte_carlo(n_runs=50, time_steps=12, scenario="baseline"):
    """
    Runs multiple simulations for the selected city scenario, storing the final step
    of each run for analysis.
    """
    scenario_params = get_scenario_parameters(scenario)
    final_results = {
        "Framework_Performance": [],
        "Adaptability": [],
        "Gov_Impact": [],
        "Sustainability": [],
        "Econ_Impact": [],
        "Community_WellBeing": []
    }

    for _ in range(n_runs):
        sim_data = run_simulation(time_steps=time_steps, scenario_params=scenario_params)
        # Grab final step
        final_results["Framework_Performance"].append(sim_data["Framework_Performance"][-1])
        final_results["Adaptability"].append(sim_data["Adaptability"][-1])
        final_results["Gov_Impact"].append(sim_data["Gov_Impact"][-1])
        final_results["Sustainability"].append(sim_data["Sustainability"][-1])
        final_results["Econ_Impact"].append(sim_data["Econ_Impact"][-1])
        final_results["Community_WellBeing"].append(sim_data["Community_WellBeing"][-1])

    return pd.DataFrame(final_results)

###############################################################################
# 4. VISUALIZATION & REPORT
###############################################################################

def visualize_time_series(sim_data, title="Single Run Time Series"):
    """
    Plots the time series for the 6 key metrics in one run.
    """
    df = pd.DataFrame({
        "Framework_Performance": sim_data["Framework_Performance"],
        "Adaptability": sim_data["Adaptability"],
        "Gov_Impact": sim_data["Gov_Impact"],
        "Sustainability": sim_data["Sustainability"],
        "Econ_Impact": sim_data["Econ_Impact"],
        "Community_WellBeing": sim_data["Community_WellBeing"]
    })

    df.plot(subplots=True, figsize=(10,10), layout=(3,2), sharex=True)
    plt.suptitle(title)
    plt.tight_layout()
    plt.show()

def analyze_scenario_results(df_results, scenario_name="Baseline", export_csv=True):
    """
    Prints summary stats, plots histograms, and exports correlations for the final-step
    distribution of each metric under Monte Carlo simulations.
    """
    print(f"\n=== {scenario_name.upper()} SCENARIO RESULTS ===")
    summary_stats = df_results.describe(percentiles=[0.025, 0.5, 0.975])
    print(summary_stats)

    # Correlation calculation
    correlation_matrix = df_results.corr()

    # Export correlations to CSV
    if export_csv:
        csv_filename = f"{scenario_name.lower().replace(' ', '_')}_correlation_results.csv"
        correlation_matrix.to_csv(csv_filename)
        print(f"Correlation matrix exported to: {csv_filename}")

    # Plotting histograms
    columns = df_results.columns
    fig, axes = plt.subplots(2, 3, figsize=(12, 8))
    axes = axes.flatten()
    for i, col in enumerate(columns):
        sns.histplot(df_results[col], kde=True, ax=axes[i])
        axes[i].set_title(col)

    plt.suptitle(f"{scenario_name.title()} Scenario - Final Step Distribution")
    plt.tight_layout()
    plt.show()


###############################################################################
# 5. MAIN (DEMONSTRATION)
###############################################################################

if __name__ == "__main__":
    # SCENARIOS FOR RQ4
    scenarios = [
        "baseline",
        "optimized_resource",
        "stress_test",
        "community_engagement",
        "governance_reform"
    ]

    for scenario in scenarios:
        print(f"\n--- RUNNING SCENARIO: {scenario} ---")

        # (A) Single run time series
        scenario_params = get_scenario_parameters(scenario)
        single_run_output = run_simulation(time_steps=12, scenario_params=scenario_params)
        visualize_time_series(single_run_output, title=f"{scenario.title()} - Single Run Time Series")

        # (B) Monte Carlo final distribution
        df_final = run_monte_carlo(n_runs=50, time_steps=12, scenario=scenario)
        analyze_scenario_results(df_final, scenario_name=scenario)